# Load package#
library(networkD3)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate degree for all nodes#
nodeList <- cbind(nodeList, nodeDegree=igraph::degree(gD, v = igraph::V(gD), mode = "all"))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# We will also create a set of colors for each edge, based on their dice similarity values#
# We'll interpolate edge colors based on the using the "colorRampPalette" function, that #
# returns a function corresponding to a collor palete of "bias" number of elements (in our case, that#
# will be a total number of edges, i.e., number of rows in the edgeList data frame)#
F2 <- colorRampPalette(c("#FFFF00", "#FF0000"), bias = nrow(edgeList), space = "rgb", interpolate = "linear")#
colCodes <- F2(length(unique(edgeList$diceSim)))#
edges_col <- sapply(edgeList$diceSim, function(x) colCodes[which(sort(unique(edgeList$diceSim)) == x)])#
#
rm(colCodes, F2)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Nodesize = "nodeBetweenness",  # value from the node list (data frame) that contains value we want to use for a node size#
                        height = 500, # Size of the plot (vertical)#
                        width = 1000,  # Size of the plot (horizontal)#
                        fontSize = 20, # Font size#
                        linkDistance = networkD3::JS("function(d) { return 10*d.value; }"), # Function to determine distance between any two nodes, uses variables already defined in forceNetwork function (not variables from a data frame)#
                        linkWidth = networkD3::JS("function(d) { return d.value/5; }"),# Function to determine link/edge thickness, uses variables already defined in forceNetwork function (not variables from a data frame)#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1, # opacity of labels when static#
                        linkColour = edges_col) # edge colors#
#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate degree for all nodes#
nodeList <- cbind(nodeList, nodeDegree=igraph::degree(gD, v = igraph::V(gD), mode = "all"))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# We will also create a set of colors for each edge, based on their dice similarity values#
# We'll interpolate edge colors based on the using the "colorRampPalette" function, that #
# returns a function corresponding to a collor palete of "bias" number of elements (in our case, that#
# will be a total number of edges, i.e., number of rows in the edgeList data frame)#
F2 <- colorRampPalette(c("#FFFF00", "#FF0000"), bias = nrow(edgeList), space = "rgb", interpolate = "linear")#
colCodes <- F2(length(unique(edgeList$diceSim)))#
edges_col <- sapply(edgeList$diceSim, function(x) colCodes[which(sort(unique(edgeList$diceSim)) == x)])#
#
rm(colCodes, F2)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Nodesize = "nodeBetweenness",  # value from the node list (data frame) that contains value we want to use for a node size#
                        Group = "nodeDegree",  # value from the node list (data frame) that contains value we want to use for node color#
                        height = 500, # Size of the plot (vertical)#
                        width = 1000,  # Size of the plot (horizontal)#
                        fontSize = 20, # Font size#
                        linkDistance = networkD3::JS("function(d) { return 10*d.value; }"), # Function to determine distance between any two nodes, uses variables already defined in forceNetwork function (not variables from a data frame)#
                        linkWidth = networkD3::JS("function(d) { return d.value/5; }"),# Function to determine link/edge thickness, uses variables already defined in forceNetwork function (not variables from a data frame)#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1, # opacity of labels when static#
                        linkColour = edges_col) # edge colors#
#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate degree for all nodes#
nodeList <- cbind(nodeList, nodeDegree=igraph::degree(gD, v = igraph::V(gD), mode = "all"))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# We will also create a set of colors for each edge, based on their dice similarity values#
# We'll interpolate edge colors based on the using the "colorRampPalette" function, that #
# returns a function corresponding to a collor palete of "bias" number of elements (in our case, that#
# will be a total number of edges, i.e., number of rows in the edgeList data frame)#
F2 <- colorRampPalette(c("#FFFF00", "#FF0000"), bias = nrow(edgeList), space = "rgb", interpolate = "linear")#
colCodes <- F2(length(unique(edgeList$diceSim)))#
edges_col <- sapply(edgeList$diceSim, function(x) colCodes[which(sort(unique(edgeList$diceSim)) == x)])#
#
rm(colCodes, F2)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Nodesize = "nodeBetweenness",  # value from the node list (data frame) that contains value we want to use for a node size#
                        Group = "nodeDegree",  # value from the node list (data frame) that contains value we want to use for node color#
                        height = 500, # Size of the plot (vertical)#
                        width = 1000,  # Size of the plot (horizontal)#
                        fontSize = 20, # Font size#
                        linkDistance = networkD3::JS("function(d) { return 10*d.value; }"), # Function to determine distance between any two nodes, uses variables already defined in forceNetwork function (not variables from a data frame)#
                        linkWidth = networkD3::JS("function(d) { return d.value/5; }"),# Function to determine link/edge thickness, uses variables already defined in forceNetwork function (not variables from a data frame)#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1, # opacity of labels when static#
                        linkColour = edges_col) # edge colors#
#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate degree for all nodes#
nodeList <- cbind(nodeList, nodeDegree=igraph::degree(gD, v = igraph::V(gD), mode = "all"))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# We will also create a set of colors for each edge, based on their dice similarity values#
# We'll interpolate edge colors based on the using the "colorRampPalette" function, that #
# returns a function corresponding to a collor palete of "bias" number of elements (in our case, that#
# will be a total number of edges, i.e., number of rows in the edgeList data frame)#
F2 <- colorRampPalette(c("#FFFF00", "#FF0000"), bias = nrow(edgeList), space = "rgb", interpolate = "linear")#
colCodes <- F2(length(unique(edgeList$diceSim)))#
edges_col <- sapply(edgeList$diceSim, function(x) colCodes[which(sort(unique(edgeList$diceSim)) == x)])#
#
rm(colCodes, F2)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Nodesize = "nodeBetweenness",  # value from the node list (data frame) that contains value we want to use for a node size#
                        Group = "nodeDegree",  # value from the node list (data frame) that contains value we want to use for node color#
                        fontSize = 20, # Font size#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1, # opacity of labels when static#
                        linkColour = edges_col) # edge colors#
#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)#
#
#################################################################################
# sessionInfo()#
##
# R version 3.3.1 (2016-06-21)#
# Platform: x86_64-redhat-linux-gnu (64-bit)#
# Running under: Fedora 24 (Workstation Edition)#
# #
# locale:#
#   [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8       #
# [4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   #
# [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C              #
# [10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       #
# #
# attached base packages:#
#   [1] stats     graphics  grDevices utils     datasets  methods   base     #
# #
# loaded via a namespace (and not attached):#
#   [1] htmlwidgets_0.7  plyr_1.8.4       magrittr_1.5     htmltools_0.3.5  tools_3.3.1      igraph_1.0.1    #
# [7] yaml_2.1.13      Rcpp_0.12.7      jsonlite_1.1     digest_0.6.10    networkD3_0.2.13
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate degree for all nodes#
nodeList <- cbind(nodeList, nodeDegree=igraph::degree(gD, v = igraph::V(gD), mode = "all"))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# We will also create a set of colors for each edge, based on their dice similarity values#
# We'll interpolate edge colors based on the using the "colorRampPalette" function, that #
# returns a function corresponding to a collor palete of "bias" number of elements (in our case, that#
# will be a total number of edges, i.e., number of rows in the edgeList data frame)#
F2 <- colorRampPalette(c("#FFFF00", "#FF0000"), bias = nrow(edgeList), space = "rgb", interpolate = "linear")#
colCodes <- F2(length(unique(edgeList$diceSim)))#
edges_col <- sapply(edgeList$diceSim, function(x) colCodes[which(sort(unique(edgeList$diceSim)) == x)])#
#
rm(colCodes, F2)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Nodesize = "nodeBetweenness",  # value from the node list (data frame) that contains value we want to use for a node size#
                        Group = "nodeDegree",  # value from the node list (data frame) that contains value we want to use for node color#
                        fontSize = 20, # Font size#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1, # opacity of labels when static#
                        linkColour = edges_col) # edge colors#
#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)#
#
#################################################################################
# sessionInfo()#
##
# R version 3.3.1 (2016-06-21)#
# Platform: x86_64-redhat-linux-gnu (64-bit)#
# Running under: Fedora 24 (Workstation Edition)#
# #
# locale:#
#   [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8       #
# [4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   #
# [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C              #
# [10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       #
# #
# attached base packages:#
#   [1] stats     graphics  grDevices utils     datasets  methods   base     #
# #
# loaded via a namespace (and not attached):#
#   [1] htmlwidgets_0.7  plyr_1.8.4       magrittr_1.5     htmltools_0.3.5  tools_3.3.1      igraph_1.0.1    #
# [7] yaml_2.1.13      Rcpp_0.12.7      jsonlite_1.1     digest_0.6.10    networkD3_0.2.13
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate degree for all nodes#
nodeList <- cbind(nodeList, group=rep(0,999))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# We will also create a set of colors for each edge, based on their dice similarity values#
# We'll interpolate edge colors based on the using the "colorRampPalette" function, that #
# returns a function corresponding to a collor palete of "bias" number of elements (in our case, that#
# will be a total number of edges, i.e., number of rows in the edgeList data frame)#
F2 <- colorRampPalette(c("#FFFF00", "#FF0000"), bias = nrow(edgeList), space = "rgb", interpolate = "linear")#
colCodes <- F2(length(unique(edgeList$diceSim)))#
edges_col <- sapply(edgeList$diceSim, function(x) colCodes[which(sort(unique(edgeList$diceSim)) == x)])#
#
rm(colCodes, F2)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Nodesize = "nodeBetweenness",  # value from the node list (data frame) that contains value we want to use for a node size#
                        Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                        fontSize = 20, # Font size#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1, # opacity of labels when static#
                        linkColour = edges_col) # edge colors#
#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)#
#
#################################################################################
# sessionInfo()#
##
# R version 3.3.1 (2016-06-21)#
# Platform: x86_64-redhat-linux-gnu (64-bit)#
# Running under: Fedora 24 (Workstation Edition)#
# #
# locale:#
#   [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8       #
# [4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   #
# [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C              #
# [10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       #
# #
# attached base packages:#
#   [1] stats     graphics  grDevices utils     datasets  methods   base     #
# #
# loaded via a namespace (and not attached):#
#   [1] htmlwidgets_0.7  plyr_1.8.4       magrittr_1.5     htmltools_0.3.5  tools_3.3.1      igraph_1.0.1    #
# [7] yaml_2.1.13      Rcpp_0.12.7      jsonlite_1.1     digest_0.6.10    networkD3_0.2.13
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate degree for all nodes#
nodeList <- cbind(nodeList, group=rep(0,999))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Nodesize = "nodeBetweenness",  # value from the node list (data frame) that contains value we want to use for a node size#
                        Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                        fontSize = 20, # Font size#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)#
#
#################################################################################
# sessionInfo()#
##
# R version 3.3.1 (2016-06-21)#
# Platform: x86_64-redhat-linux-gnu (64-bit)#
# Running under: Fedora 24 (Workstation Edition)#
# #
# locale:#
#   [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8       #
# [4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   #
# [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C              #
# [10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       #
# #
# attached base packages:#
#   [1] stats     graphics  grDevices utils     datasets  methods   base     #
# #
# loaded via a namespace (and not attached):#
#   [1] htmlwidgets_0.7  plyr_1.8.4       magrittr_1.5     htmltools_0.3.5  tools_3.3.1      igraph_1.0.1    #
# [7] yaml_2.1.13      Rcpp_0.12.7      jsonlite_1.1     digest_0.6.10    networkD3_0.2.13
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate degree for all nodes#
nodeList <- cbind(nodeList, group=rep(0,nrow(nodeList)))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Nodesize = "nodeBetweenness",  # value from the node list (data frame) that contains value we want to use for a node size#
                        Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                        fontSize = 20, # Font size#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Set the group of the nodes for the color representation#
nodeList <- cbind(nodeList, group=rep(0,nrow(nodeList)))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                        fontSize = 20, # Font size#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(nodeList$nodeBetweenness),]#
ones <- rep(1,50)#
zeros <- rep(0, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(ones,zeros))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
ones <- rep(1,50)#
zeros <- rep(0, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(ones,zeros))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(9,50)#
nocolor <- rep(0, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(9,50)#
nocolor <- rep(0, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
F2 <- colorRampPalette(c("#FFFF00", "#FF0000"), bias = nrow(edgeList), space = "rgb", interpolate = "linear")#
colCodes <- F2(length(unique(edgeList$diceSim)))#
edges_col <- sapply(edgeList$diceSim, function(x) colCodes[which(sort(unique(edgeList$diceSim)) == x)])#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(9,50)#
nocolor <- rep(0, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory20);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(9,50)#
nocolor <- rep(0, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(9, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeAccent);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemePaired);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.interpolateBrBG);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeSet1);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep("#bf3eff",50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Set the group of the nodes for the color representation#
nodeList <- cbind(nodeList, group=rep(0,nrow(nodeList)))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                        fontSize = 20, # Font size#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM1.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleSequential(d3.interpolateRdBu);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeAccent[2]);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeAccent);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeAccent);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeAccent[2]);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleSequential(d3.interpolatePiYG);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleSequential(d3.interpolatePiYG);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory2);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
d3.scaleSequential(d3.interpolateRdBu)#
d3.interpolateRdBu#
#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10[2]);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
d3.scaleSequential(d3.interpolateRdBu)#
d3.interpolateRdBu#
#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(0,50)#
nocolor <- rep(1, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10(2));"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
d3.scaleSequential(d3.interpolateRdBu)#
d3.interpolateRdBu#
#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(-nodeList$nodeBetweenness),]#
color <- rep(1,50)#
nocolor <- rep(3, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(color,nocolor))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
d3.scaleSequential(d3.interpolateRdBu)#
d3.interpolateRdBu#
#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(nodeList$nodeBetweenness),]#
color <- rep(1,50)#
nocolor <- rep(3, nrow(nodeList)-50)#
#
nodeList <- cbind(nodeList, group= c(nocolor,color))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
d3.scaleSequential(d3.interpolateRdBu)#
d3.interpolateRdBu#
#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Set the group of the nodes for the color representation#
nodeList <- cbind(nodeList, group=rep(0,nrow(nodeList)))#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                           function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                        Nodes = nodeList, # data frame that contains info about nodes#
                        Source = "SourceID", # ID of source node #
                        Target = "TargetID", # ID of target node#
                        NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                        Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                        fontSize = 20, # Font size#
                        opacity = 0.85, # opacity#
                        zoom = TRUE, # ability to zoom when click on the node#
                        opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM1.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(nodeList$nodeBetweenness),]#
nocolor <- rep(3, nrow(nodeList)-50)#
color <- rep(1,50)#
nodeList <- cbind(nodeList, group= c(nocolor,color))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
d3.scaleSequential(d3.interpolateRdBu)#
d3.interpolateRdBu#
#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) #
#
nodeList <- cbind(nodeList, nodeBetweenness=betAll) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(nodeList$nodeBetweenness),]#
nocolor <- rep(3, nrow(nodeList)-50)#
color <- rep(1,50)#
nodeList <- cbind(nodeList, group= c(nocolor,color))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
d3.scaleSequential(d3.interpolateRdBu)#
d3.interpolateRdBu#
#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) #
#
nodeList <- cbind(nodeList, nodeBetweenness=betAll) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(nodeList$nodeBetweenness),]#
nocolor <- rep(3, nrow(nodeList)-50)#
color <- rep(1,50)#
nodeList <- cbind(nodeList, group= c(nocolor,color))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
d3.scaleSequential(d3.interpolateRdBu)#
d3.interpolateRdBu#
#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList <- nodeList[order(nodeList$nodeBetweenness),]#
nocolor <- rep(3, nrow(nodeList)-2)#
color <- rep(1,2)#
nodeList <- cbind(nodeList, group= c(nocolor,color))#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
d3.scaleSequential(d3.interpolateRdBu)#
d3.interpolateRdBu#
#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
# Load package#
library(networkD3)#
library(igraph)#
#
# Set working directory#
setwd("/Volumes/Nano/Documentos/Nano/Universidad/Asignaturas/TFM/R")#
#
# Import nodes from 2 .csv #
from <- scan('CSVfrom.csv', what=character(), sep=",", quiet=TRUE)#
to <- scan('CSVto.csv', what=character(), sep=",", quiet=TRUE)#
#
# Create a dataframe from the imported files#
edgeList <- data.frame(from, to)#
colnames(edgeList) <- c("SourceName", "TargetName")#
#
# Create a graph. Use simplyfy to ensure that there are no duplicated edges or self loops#
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))#
#
# Create a node list object (actually a data frame object) that will contain information about nodes#
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), # because networkD3 library requires IDs to start at 0#
                       nName = igraph::V(gD)$name)#
#
# Map node names from the edge list to node IDs#
getNodeID <- function(x){#
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0#
}#
# And add them to the edge list#
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName"), #
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), #
                                                TargetID = getNodeID(x$TargetName)))#
#
#############################################################################################
# Calculate some node properties and node similarities that will be used to illustrate #
# different plotting abilities and add them to the edge and node lists#
#
# Calculate betweenness for all nodes#
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)#
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))#
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) # We are scaling the value by multiplying it by 100 for visualization purposes only (to create larger nodes)#
rm(betAll, betAll.norm)#
#
# Set the new property which will determine the color of the nodes, based on their betweenness#
nodeList2 <- nodeList[order(nodeList$nodeBetweenness),]#
nocolor <- rep(3, nrow(nodeList)-50)#
color <- rep(1,50)#
nodeList2 <- cbind(nodeList2, group = c(nocolor,color))#
#
nodeList <- cbind(nodeList, group=rep(0,nrow(nodeList)))#
nodeList$group[match(nodeList2$ID, nodeList$ID)] <- nodeList2$group#
#
#Calculate Dice similarities between all pairs of nodes#
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")#
#
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}#
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "SourceID", "TargetID"), #
                        function(x) data.frame(F1(x)))#
#
rm(dsAll, F1, getNodeID, gD)#
#############################################################################################
# Let's create a network#
#
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, # data frame that contains info about edges#
                                         Nodes = nodeList, # data frame that contains info about nodes#
                                         Source = "SourceID", # ID of source node #
                                         Target = "TargetID", # ID of target node#
                                         NodeID = "nName", # value from the node list (data frame) that contains node description we want to use (e.g., node name)#
                                         Group = "group",  # value from the node list (data frame) that contains value we want to use for node color#
                                         colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),#
                                         fontSize = 20, # Font size#
                                         opacity = 0.85, # opacity#
                                         zoom = TRUE, # ability to zoom when click on the node#
                                         opacityNoHover = 0.1) # opacity of labels when static#
# Plot network#
D3_network_LM #
#
# Save network as html file#
networkD3::saveNetwork(D3_network_LM, "D3_LM2.html", selfcontained = TRUE)
